<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Heart</title>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <style>
            :root {
                --main-color: #ff5ca4;
            }
            html,
            body {
                height: 100%;
                padding: 0;
                margin: 0;
                background: #000;
                display: flex;
                justify-content: center;
                align-items: center;
                overflow: hidden;
            }
            .box {
                width: 100%;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                flex-direction: column;
            }
            canvas {
                position: absolute;
                width: 100%;
                height: 100%;
            }
            #pinkboard {
                position: relative;
                margin: auto;
                height: 500px;
                width: 500px;
                animation: animate 1.3s infinite;
            }
            #pinkboard:before,
            #pinkboard:after {
                content: '';
                position: absolute;
                background: var(--main-color);
                width: 100px;
                height: 160px;
                border-top-left-radius: 50px;
                border-top-right-radius: 50px;
            }
            #pinkboard:before {
                left: 100px;
                transform: rotate(-45deg);
                transform-origin: 0 100%;
                box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
            }
            #pinkboard:after {
                left: 0;
                transform: rotate(45deg);
                transform-origin: 100% 100%;
            }
            .text-highlight {
                background-color: transparent;
                width: 100%;
                color: var(--main-color);
                height: 100%;
                font-size: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-bottom: 5px;
                text-align: center;
                animation: animate 1.3s infinite;
                position: relative;
                height: 200px;
                width: 200px;
            }
            .text-highlight p {
                font-size: 80px;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                margin: 0;
            }
            @keyframes animate {
                0% {
                    transform: scale(1);
                }
                30% {
                    transform: scale(0.8);
                }
                60% {
                    transform: scale(1.2);
                }
                100% {
                    transform: scale(1);
                }
            }
        </style>
    </head>
    <body>
        <div class="box">
            <canvas id="pinkboard"></canvas>
        </div>
        <div id="text" class="center-text text-highlight"></div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/TextPlugin.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/EasePack.min.js"></script>
        <script>
            /*
             * Settings
             */
            var settings = {
                particles: {
                    length: 2000, // maximum amount of particles
                    duration: 2, // particle duration in sec
                    velocity: 100, // particle velocity in pixels/sec
                    effect: -1.3, // play with this for a nice effect
                    size: 13, // particle size in pixels
                },
            }
            /*
             * RequestAnimationFrame polyfill by Erik MÃ¶ller
             */
            ;(function () {
                var b = 0
                var c = ['ms', 'moz', 'webkit', 'o']
                for (var a = 0; a < c.length && !window.requestAnimationFrame; ++a) {
                    window.requestAnimationFrame = window[c[a] + 'RequestAnimationFrame']
                    window.cancelAnimationFrame =
                        window[c[a] + 'CancelAnimationFrame'] || window[c[a] + 'CancelRequestAnimationFrame']
                }
                if (!window.requestAnimationFrame) {
                    window.requestAnimationFrame = function (h, e) {
                        var d = new Date().getTime()
                        var f = Math.max(0, 16 - (d - b))
                        var g = window.setTimeout(function () {
                            h(d + f)
                        }, f)
                        b = d + f
                        return g
                    }
                }
                if (!window.cancelAnimationFrame) {
                    window.cancelAnimationFrame = function (d) {
                        clearTimeout(d)
                    }
                }
            })()
            /*
             * Point class
             */
            var Point = (function () {
                function Point(x, y) {
                    this.x = typeof x !== 'undefined' ? x : 0
                    this.y = typeof y !== 'undefined' ? y : 0
                }
                Point.prototype.clone = function () {
                    return new Point(this.x, this.y)
                }
                Point.prototype.length = function (length) {
                    if (typeof length == 'undefined') return Math.sqrt(this.x * this.x + this.y * this.y)
                    this.normalize()
                    this.x *= length
                    this.y *= length
                    return this
                }
                Point.prototype.normalize = function () {
                    var length = this.length()
                    this.x /= length
                    this.y /= length
                    return this
                }
                return Point
            })()
            /*
             * Particle class
             */
            var Particle = (function () {
                function Particle() {
                    this.position = new Point()
                    this.velocity = new Point()
                    this.acceleration = new Point()
                    this.age = 0
                }
                Particle.prototype.initialize = function (x, y, dx, dy) {
                    this.position.x = x
                    this.position.y = y
                    this.velocity.x = dx
                    this.velocity.y = dy
                    this.acceleration.x = dx * settings.particles.effect
                    this.acceleration.y = dy * settings.particles.effect
                    this.age = 0
                }
                Particle.prototype.update = function (deltaTime) {
                    this.position.x += this.velocity.x * deltaTime
                    this.position.y += this.velocity.y * deltaTime
                    this.velocity.x += this.acceleration.x * deltaTime
                    this.velocity.y += this.acceleration.y * deltaTime
                    this.age += deltaTime
                }
                Particle.prototype.draw = function (context, image) {
                    function ease(t) {
                        return --t * t * t + 1
                    }
                    var size = image.width * ease(this.age / settings.particles.duration)
                    context.globalAlpha = 1 - this.age / settings.particles.duration
                    context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size)
                }
                return Particle
            })()
            /*
             * ParticlePool class
             */
            var ParticlePool = (function () {
                var particles,
                    firstActive = 0,
                    firstFree = 0,
                    duration = settings.particles.duration
                function ParticlePool(length) {
                    // create and populate particle pool
                    particles = new Array(length)
                    for (var i = 0; i < particles.length; i++) particles[i] = new Particle()
                }
                ParticlePool.prototype.add = function (x, y, dx, dy) {
                    particles[firstFree].initialize(x, y, dx, dy)
                    // handle circular queue
                    firstFree++
                    if (firstFree == particles.length) firstFree = 0
                    if (firstActive == firstFree) firstActive++
                    if (firstActive == particles.length) firstActive = 0
                }
                ParticlePool.prototype.update = function (deltaTime) {
                    var i
                    // update active particles
                    if (firstActive < firstFree) {
                        for (i = firstActive; i < firstFree; i++) particles[i].update(deltaTime)
                    }
                    if (firstFree < firstActive) {
                        for (i = firstActive; i < particles.length; i++) particles[i].update(deltaTime)
                        for (i = 0; i < firstFree; i++) particles[i].update(deltaTime)
                    }
                    // remove inactive particles
                    while (particles[firstActive].age >= duration && firstActive != firstFree) {
                        firstActive++
                        if (firstActive == particles.length) firstActive = 0
                    }
                }
                ParticlePool.prototype.draw = function (context, image) {
                    // draw active particles
                    if (firstActive < firstFree) {
                        for (i = firstActive; i < firstFree; i++) particles[i].draw(context, image)
                    }
                    if (firstFree < firstActive) {
                        for (i = firstActive; i < particles.length; i++) particles[i].draw(context, image)
                        for (i = 0; i < firstFree; i++) particles[i].draw(context, image)
                    }
                }
                return ParticlePool
            })()
            /*
             * Putting it all together
             */
            ;(function (canvas) {
                var context = canvas.getContext('2d'),
                    particles = new ParticlePool(settings.particles.length),
                    particleRate = settings.particles.length / settings.particles.duration, // particles/sec
                    time
                // get point on heart with -PI <= t <= PI
                function pointOnHeart(t) {
                    return new Point(
                        160 * Math.pow(Math.sin(t), 3),
                        130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
                    )
                }
                // creating the particle image using a dummy canvas
                var image = (function () {
                    var canvas = document.createElement('canvas'),
                        context = canvas.getContext('2d')
                    canvas.width = settings.particles.size
                    canvas.height = settings.particles.size
                    // helper function to create the path
                    function to(t) {
                        var point = pointOnHeart(t)
                        point.x = settings.particles.size / 2 + (point.x * settings.particles.size) / 350
                        point.y = settings.particles.size / 2 - (point.y * settings.particles.size) / 350
                        return point
                    }
                    // create the path
                    context.beginPath()
                    var t = -Math.PI
                    var point = to(t)
                    context.moveTo(point.x, point.y)
                    while (t < Math.PI) {
                        t += 0.01 // baby steps!
                        point = to(t)
                        context.lineTo(point.x, point.y)
                    }
                    context.closePath()
                    // create the fill
                    context.fillStyle = '#ff5ca4'
                    context.fill()
                    // create the image
                    var image = new Image()
                    image.src = canvas.toDataURL()
                    return image
                })()
                // render that thing!
                function render() {
                    // next animation frame
                    requestAnimationFrame(render)
                    // update time
                    var newTime = new Date().getTime() / 1000,
                        deltaTime = newTime - (time || newTime)
                    time = newTime
                    // clear canvas
                    context.clearRect(0, 0, canvas.width, canvas.height)
                    // create new particles
                    var amount = particleRate * deltaTime
                    for (var i = 0; i < amount; i++) {
                        var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random())
                        var dir = pos.clone().length(settings.particles.velocity)
                        particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y)
                    }
                    // update and draw particles
                    particles.update(deltaTime)
                    particles.draw(context, image)
                }
                // handle (re-)sizing of the canvas
                function onResize() {
                    canvas.width = canvas.clientWidth
                    canvas.height = canvas.clientHeight
                }
                window.onresize = onResize
                // delay rendering bootstrap
                setTimeout(function () {
                    onResize()
                    render()
                }, 10)
            })(document.getElementById('pinkboard'))
        </script>
        <script>
            var container = $('#text'),
                _sentenceEndExp = /(\.|\?|!)$/g
            function machineGun(text) {
                var words = text.split(' '),
                    tl = gsap.timeline({ delay: 0.6, repeat: -1, repeatDelay: 1 }),
                    wordCount = words.length,
                    time = 0,
                    word,
                    element,
                    duration,
                    isSentenceEnd,
                    i
                for (i = 0; i < wordCount; i++) {
                    word = words[i]
                    isSentenceEnd = _sentenceEndExp.test(word)
                    element = $('<p>' + word + '</p>').appendTo(container)
                    duration = Math.max(0.5, word.length * 0.08) //longer words take longer to read, so adjust timing. Minimum of 0.5 seconds.
                    if (isSentenceEnd) {
                        duration += 0.6 //if it's the last word in a sentence, drag out the timing a bit for a dramatic pause.
                    }
                    //set opacity and scale to 0 initially. We set z to 0.01 just to kick in 3D rendering in the browser which makes things render a bit more smoothly.
                    gsap.set(element, { autoAlpha: 0, scale: 0, z: 0.01 })
                    //the SlowMo ease is like an easeOutIn but it's configurable in terms of strength and how long the slope is linear. See https://www.greensock.com/v12/#slowmo and https://api.greensock.com/js/com/greensock/easing/SlowMo.html
                    tl.to(element, duration, { scale: 1.2, ease: 'slow(0.25, 0.9)' }, time)
                        //notice the 3rd parameter of the SlowMo config is true in the following tween - that causes it to yoyo, meaning opacity (autoAlpha) will go up to 1 during the tween, and then back down to 0 at the end.
                        .to(element, duration, { autoAlpha: 1, ease: 'slow(0.25, 0.9, true)' }, time)
                    time += duration - 0.05
                    if (isSentenceEnd) {
                        time += 0.6 //at the end of a sentence, add a pause for dramatic effect.
                    }
                }
            }
            machineGun('M I N H H A U MINHHAU')
        </script>
    </body>
</html>